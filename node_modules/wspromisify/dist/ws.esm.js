/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function t(t,e,s,n){return new(s||(s=Promise))((function(o,i){function l(t){try{c(n.next(t))}catch(t){i(t)}}function r(t){try{c(n.throw(t))}catch(t){i(t)}}function c(t){t.done?o(t.value):new s((function(e){e(t.value)})).then(l,r)}c((n=n.apply(t,e||[])).next())}))}const e="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",s=e.length-1;const n=(t,e,s)=>t.addEventListener(e,s),o=t=>{let e=!1,s=null;return(...n)=>e?s:(e=!0,s=t(...n))},i=function(e){const s=this.config;this.open=!0,this.onReadyQueue.forEach(t=>t()),this.onReadyQueue.splice(0);const{id_key:o,data_key:i}=s.server;this.messages.forEach(t=>t.send()),null!==this.reconnect_timeout&&(clearInterval(this.reconnect_timeout),this.reconnect_timeout=null),n(e,"close",()=>t(this,void 0,void 0,(function*(){this.log("close"),this.open=!1,this.onCloseQueue.forEach(t=>t()),this.onCloseQueue=[];const e=s.reconnect;if("number"!=typeof e||isNaN(e)||this.forcibly_closed)this.ws=null,this.open=null;else{const s=()=>t(this,void 0,void 0,(function*(){this.log("reconnect"),null!==this.ws&&(this.ws.close(),this.ws=null),null!==(yield this.connect())&&(this.reconnect_timeout=setTimeout(s,1e3*e))}));s()}this.forcibly_closed=!1}))),n(e,"message",t=>{try{const e=s.decode(t.data);if(this.messageHandlers.forEach(s=>s(Object.assign(Object.assign({},t),{data:e}))),e[o]){const t=this.queue[e[o]];if(t){const s=t.sent_time?Date.now()-t.sent_time:null;this.log("message",e[i],s),t.ff(e[i]),clearTimeout(t.timeout),delete this.queue[e[o]]}}}catch(e){console.error(e,`WSP: Decode error. Got: ${t.data}`)}})},l=function(t){if(!0===this.open)return t(null);const e=this.config,s=e.socket||e.adapter(e.url,e.protocols);if(this.ws=s,!s||s.readyState>1)return this.ws=null,this.log("error","ready() on closing or closed state! status 2."),t(2);n(s,"error",o(()=>(this.ws=null,this.log("error","status 3."),t(3)))),s.readyState?(i.call(this,s),t(null)):n(s,"open",o(()=>(this.log("open"),i.call(this,s),t(null))))},r={data_type:"json",log:()=>null,timer:!1,url:"localhost",timeout:1400,reconnect:2,lazy:!1,socket:null,adapter:(t,e)=>new WebSocket(t,e),encode:(t,e,{server:s})=>JSON.stringify({[s.id_key]:t,[s.data_key]:e}),decode:t=>JSON.parse(t),protocols:[],pipes:[],server:{id_key:"id",data_key:"data"}};var c=function(){return!0};const u=Math.pow(2,31)-1;export default class{constructor(t={}){this.open=null,this.ws=null,this.forcibly_closed=!1,this.reconnect_timeout=null,this.queue={},this.messages=[],this.onReadyQueue=[],this.onCloseQueue=[],this.messageHandlers=[],this.config={},this.config=(t=>{const e=Object.assign({},r,t),s=e.url;if("/"==s[0])try{const t=location.protocol.includes("s:")?"wss":"ws";e.url=`${t}://${location.hostname}:${location.port}${s}`}catch(t){throw new Error("WSP: URL starting with / in non-browser environment!")}return e})(t),this.init_flush(),this.open=!1,this.reconnect_timeout=null,this.forcibly_closed=!1,this.config.lazy||this.connect()}init_flush(){this.queue={},this.messages=[]}log(t,e=null,s=null){const n=this.config;null!==s?n.log(t,s,e):n.timer?n.log(t,null,e):n.log(t,e)}connect(){return t(this,void 0,void 0,(function*(){return new Promise(t=>{l.call(this,t)})}))}get socket(){return this.ws}ready(){return t(this,void 0,void 0,(function*(){return new Promise(t=>{this.open?t():this.onReadyQueue.push(t)})}))}on(t,e,s=c,o=!1){const i=t=>s(t)&&e(t);return o||"message"!==t?n(this.ws,t,i):this.messageHandlers.push(i)}close(){return t(this,void 0,void 0,(function*(){return new Promise((t,e)=>{null===this.ws?e("WSP: closing a non-inited socket!"):(this.open=null,this.onCloseQueue.push(()=>{this.init_flush(),this.ws=null,this.forcibly_closed=!0,t(null)}),this.ws.close())})}))}send(n,o={}){return t(this,void 0,void 0,(function*(){this.log("send",n);const t=this.config,i={},l=t.server.data_key,r=t.lazy&&!this.open,c=(t=>{const n=[];for(;t>=1;)n.push(e[t%(s+1)]),t=t/s|0;return n.join("")})(Math.random()*(u-10)|0);if("object"==typeof o.top){if(o.top[l])throw new Error("Attempting to set data key/token via send() options!");Object.assign(i,o.top)}if(t.pipes.forEach(t=>n=t(n)),!0===this.open)this.ws.send(t.encode(c,n,t));else if(!1===this.open||r)this.messages.push({send:()=>this.ws.send(t.encode(c,n,t))}),r&&this.connect();else if(null===this.open)throw new Error("Attempting to send via closed WebSocket connection!");return new Promise((e,s)=>{var n,o;this.queue[c]={ff:e,data_type:t.data_type,sent_time:t.timer?Date.now():null,timeout:(n=t.timeout,o=()=>{this.queue[c]&&(s({"Websocket timeout expired: ":t.timeout,"for the message":i}),delete this.queue[c])},setTimeout(o,n))}})}))}}
